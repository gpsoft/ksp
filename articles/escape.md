# エスケープシーケンスは、何から逃げているのか?

## 例

多くのプログラミング言語では、ダブルクオートで囲むことにより文字列リテラルを表記します。以下、コード例はphpです。

```php
$a = "Hello, world!";
```

### 例1

ここで、`Hello,`と`world!`の間に`"wonderful"`を入れたい場合、`"Hello, "wonderful" world!"`とは書けません。ダブルクオートで文字列リテラルを始めた場合、次に来るダブルクオートは「文字列リテラルの終わり」と解釈されるからです。それを避けて、「ただのダブルクオート」と解釈してもらうには、エスケープシーケンスを使います。

```php
$b = "Hello, \"wonderful\" world!";
```

`wonderful`の前後にある `\"` がエスケープシーケンスです。バックスラッシュが、ダブルクオートを「文字列リテラルの終わり」という呪縛から逃し、「ただのダブルクオート」に戻しています。

### 例2

`Hello`と`world`の間で改行したい場合はどうでしょうか? そんな場合もエスケープシーケンスを使います。

```php
$c = "Hello,\nworld!";
```

`\n`がエスケープシーケンスですが、今回は、バックスラッシュが、「ただの平凡な`n`」という日常から逃し、「改行コード(linefeed)」という特別な役割を与えています。

## 正体

で、「エスケープ」とは、何からのエスケープなのか?

「ダブルクオートで囲まれた文字列リテラル」の中では、あるルールが適用されています。すなはち、

- ダブルクオートが来たら、文字列リテラルは終わる
- バックスラッシュが来たら、エスケープシーケンスが始まる
- それ以外の文字が来たら、それは、ただの文字

です。このルールが、「ダブルクオートで囲まれた文字列リテラル」のコンテキストです。そして、このコンテキストから逃してくれるのが、「エスケープ文字」であるバックスラッシュです。

- ダブルクオートの前にバックスラッシュを付けると、ただのダブルクオート(文字列リテラルは終わらない)
- バックスラッシュの前にバックスラッシュを付けると、ただのバックスラッシュ(エスケープシーケンスは始まらない)
- それ以外の文字の前にバックスラッシュを付けると、エスケープシーケンス(ただの文字ではない)

うん、うまく説明できたね!

## 補足

細かいツッコミを入れると、

- 「(エスケープシーケンスは始まらない)」というのはウソで、"&#92;&#92;"自体がエスケープシーケンス
- 「(ただの文字ではない)」というのも言い過ぎで、「(ただの文字ではない可能性がある)」が正解

です。

特に、実際のところ、「それ以外の文字の前にバックスラッシュを付けると、エスケープシーケンス」になるのは、ごく限られた文字だけです。エスケープシーケンスにならないケースでは、どう解釈されるのか? それは言語(や言語のバージョン)によって異なります。

たとえばphpの「ダブルクオートで囲まれた文字列リテラル」に関して言えば、[12個のエスケープシーケンスが定義](https://www.php.net/manual/ja/language.types.string.php#language.types.string.syntax.double)されています。これによれば、`"\c"`はエスケープシーケンスではありません。そして…

```php
echo "\c";
```

最近のバージョンのphpでは、上記のコードは、「バックスラッシュと`c`」を出力します。これがもしC言語だったら、`c`だけが出力されるはずです(違ったっけ?)。

